
process {
    executor = 'pbspro'
    project = 'tu07' // change according to the project 
    queue = 'normal'
    module = 'singularity'
    storage = 'gdata/tu07' // change according to the project 
    beforeScript = 'module load singularity'

    withLabel:process_single {
        cpus   = { check_max( 1                  , 'cpus'    ) }
        memory = { check_max( 4.GB * task.attempt, 'memory'  ) }
        time   = { check_max( 4.h  * task.attempt, 'time'    ) }
    }

    withLabel:process_low {
        cpus   = { check_max( 2     * task.attempt, 'cpus'    ) }
        memory = { check_max( 8.GB * task.attempt, 'memory'  ) }
        time   = { check_max( 4.h   * task.attempt, 'time'    ) }
    }

    withLabel:process_medium {
        cpus   = { check_max( 6     * task.attempt, 'cpus'    ) }
        memory = { check_max( 24.GB * task.attempt, 'memory'  ) }
        time   = { check_max( 8.h   * task.attempt, 'time'    ) }
    }

    withLabel:process_high {
        cpus   = { check_max( 12    * task.attempt, 'cpus'    ) }
        memory = { check_max( 48.GB * task.attempt, 'memory'  ) }
        time   = { check_max( 16.h  * task.attempt, 'time'    ) }
    }

    // sending these (uses 1 CPU in most cases) to 'normalbw' to avoid getting the singularity related error "FATAL: container creation failed"
    withName: 'ODGI.*|GFAFFIX' {
        queue = 'normalbw'
    }

    // use $PBS_JOBFS as scratch to avoid high load on the Lustre filesystem
    withName: SEQWISH {
        disk = '48GB'
        scratch = '$PBS_JOBFS'
    }

    withName: WFMASH_MAP_COMMUNITY {
        cpus = 48
        memory = '192GB'
        time = '12.h'
    }

    withName: WFMASH_MAP_REFERENCE_BASED_COMMUNITY {
        cpus = 48
        memory = '192GB'
        time = '12.h'
    }

    withName: WFMASH_UNMAPPED_REMAP_REFERENCE_BASED_COMMUNITY {
        cpus = 24
        memory = '96GB'
        time = '6.h'
    }

    withName: WFMASH_MAP {
        cpus = 8
        memory = '32GB'
        time = '8.h'
    }

    withName: ODGI_LAYOUT {
        cpus = 15
        memory = '60GB'
        time = '5.h'
    }

    withName: 'ODGI_VIZ.*' {
        cpus = 4
        memory = '16GB'
        time = '1.h'
    }
}

params {
    max_cpus   = 48
    max_memory = '192.GB'
    max_time   = '24.h'
}

// Function to ensure that resource requirements don't go beyond
// a maximum limit (copied from nextflow.config)
def check_max(obj, type) {
    if (type == 'memory') {
        try {
            if (obj.compareTo(params.max_memory as nextflow.util.MemoryUnit) == 1)
                return params.max_memory as nextflow.util.MemoryUnit
            else
                return obj
        } catch (all) {
            println "   ### ERROR ###   Max memory '${params.max_memory}' is not valid! Using default value: $obj"
            return obj
        }
    } else if (type == 'time') {
        try {
            if (obj.compareTo(params.max_time as nextflow.util.Duration) == 1)
                return params.max_time as nextflow.util.Duration
            else
                return obj
        } catch (all) {
            println "   ### ERROR ###   Max time '${params.max_time}' is not valid! Using default value: $obj"
            return obj
        }
    } else if (type == 'cpus') {
        try {
            return Math.min( obj, params.max_cpus as int )
        } catch (all) {
            println "   ### ERROR ###   Max cpus '${params.max_cpus}' is not valid! Using default value: $obj"
            return obj
        }
    }
}